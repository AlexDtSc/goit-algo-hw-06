# goit-algo-hw-06
Homework. Topic 6. "Graphs". Course "Basic Algorithms and Data Structures". 

# Опис Завдання 2
У цьому завданні реалізовано два пошукові алгоритми — глибини (DFS) та ширини (BFS) — для графа, створеного в Завданні 1. 
Ми побудували дерева обходу, які демонструють, у якому порядку алгоритми обходять вузли та які ребра використовуються для формування дерева пошуку.

## Результати
* DFS (Depth-First Search) DFS_tree search way   [('A', 'B'), ('B', 'D'), ('D', 'E'), ('E', 'H'), ('A', 'C'), ('C', 'F'), ('F', 'I'), ('F', 'G')]
* BFS (Breadth-First Search) BFS_tree search way [('A', 'B'), ('A', 'C'), ('B', 'D'), ('B', 'E'), ('C', 'F'), ('C', 'G'), ('E', 'H'), ('F', 'I')]

* Пояснення різниці:
    * DFS (обхід у глибину) прямує якомога глибше по одній гілці, перш ніж повернутись назад. Це видно у результаті: спочатку він повністю проходить шлях A → B → D → E → H, і лише потім повертається до вузла A та переходить до C.
    * BFS (обхід у ширину) проходить усіх сусідів поточного вузла, перш ніж переходити до наступного рівня. У результаті BFS одразу відкриває вузли B і C з A, потім D, E, F, G і далі.

## Висновок
* DFS підходить для задач, де потрібно дістатися до глибоких вузлів, або знайти будь-який шлях до цілі.
* BFS ефективніший, коли потрібно знайти найкоротший шлях у графі (у кількості кроків).
* Обидва алгоритми генерують дерево пошуку, яке залежить від порядку обходу сусідів. Якщо ви хочете контролювати точний порядок — варто задавати sorted() або вручну впорядкований список суміжностей.

